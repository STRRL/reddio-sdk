package com.reddio.abi.getlog

import com.reddio.abi.Deposits
import com.reddio.exception.ReddioException
import io.reactivex.Flowable
import org.web3j.protocol.Web3j
import org.web3j.protocol.core.methods.request.EthFilter
import org.web3j.protocol.core.methods.response.Log
import java.math.BigInteger

/**
 * This util class use `eth_getLogs` instead of the combination of `eth_newFilter` and `eth_getFilterLogs`, for
 * unnecessary serverside state and better performance.
 *
 * But the typed response is generated by web3j and is based on the contract ABI. So this class MUST also be manually
 * updated when the contract ABI changes.
 */
class EthGetLogsForDeposits {
    companion object {

        fun getLogsForLogDepositEvent(
            web3j: Web3j, ethFilter: EthFilter
        ): List<Deposits.LogDepositEventResponse> {
            return web3j.ethGetLogs(ethFilter).send().logs.map {
                val log = it as Log
                // see the parsing logic in com.reddio.abi.Deposits.logDepositEventFlowable(org.web3j.protocol.core.methods.request.EthFilter)
                val eventValues = Deposits.staticExtractEventParameters(Deposits.LOGDEPOSIT_EVENT, log)
                Deposits.LogDepositEventResponse().apply {
                    this.log = log
                    this.depositorEthKey = eventValues.nonIndexedValues[0].value as String
                    this.starkKey = eventValues.nonIndexedValues[1].value as BigInteger
                    this.vaultId = eventValues.nonIndexedValues[2].value as BigInteger
                    this.assetType = eventValues.nonIndexedValues[3].value as BigInteger
                    this.nonQuantizedAmount = eventValues.nonIndexedValues[4].value as BigInteger
                    this.quantizedAmount = eventValues.nonIndexedValues[5].value as BigInteger
                }
            }
        }

        fun getLogsForLogNftDepositEvent(
            web3j: Web3j, ethFilter: EthFilter
        ): List<Deposits.LogNftDepositEventResponse> {
            return web3j.ethGetLogs(ethFilter).send().logs.map {
                // if log is Log
                val log = it as Log
                // see the parsing logic in
                val eventValues = Deposits.staticExtractEventParameters(Deposits.LOGNFTDEPOSIT_EVENT, log)
                Deposits.LogNftDepositEventResponse().apply {
                    this.log = log
                    this.depositorEthKey = eventValues.nonIndexedValues[0].value as String
                    this.starkKey = eventValues.nonIndexedValues[1].value as BigInteger
                    this.vaultId = eventValues.nonIndexedValues[2].value as BigInteger
                    this.assetType = eventValues.nonIndexedValues[3].value as BigInteger
                    this.tokenId = eventValues.nonIndexedValues[4].value as BigInteger
                    this.assetId = eventValues.nonIndexedValues[5].value as BigInteger
                }
            }
        }

        fun <T> asFlowable(elements: List<T>): Flowable<T> {
            return Flowable.fromIterable(elements)
        }
    }
}